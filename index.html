<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>소리 파동 가상 실험실</title>
    <!-- PWA Manifest 연결 -->
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons UMD build for browser support -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <!-- Three.js for 3D Simulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Mobile safe area for fixed bottom bar */
        body { padding-bottom: 120px; }
        /* 3D Canvas Container */
        #threeContainer {
            width: 100%;
            height: 300px;
            position: relative;
            overflow: hidden;
            border-radius: 0.75rem; /* rounded-xl */
        }
    </style>
</head>
<body class="bg-gray-50 font-sans select-none">
    <div class="flex flex-col items-center justify-center w-full min-h-screen p-4 md:p-6 pb-40">
        <div class="w-full max-w-4xl bg-white rounded-2xl shadow-xl overflow-hidden">
            <!-- Header -->
            <div class="bg-indigo-600 p-6 text-white flex flex-col xl:flex-row justify-between items-center gap-6">
                <div>
                    <h1 class="text-2xl font-bold flex items-center gap-2 whitespace-nowrap">
                        <i data-lucide="activity" class="w-8 h-8"></i>
                        소리 파동 가상 실험실
                    </h1>
                    <p class="text-indigo-200 mt-1">주파수, 진폭, 파형을 조절하며 소리를 눈으로 확인하세요.</p>
                </div>
                
                <!-- Visual Tools Group (Kept at Top) -->
                <div class="flex gap-2 bg-indigo-700/30 p-2 rounded-2xl">
                    <button id="guideBtn" class="flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-purple-400 hover:bg-purple-500 text-white text-sm whitespace-nowrap">
                        <i data-lucide="scan-line" class="w-4 h-4 icon-guide"></i>
                        <span id="guideBtnText">점선 보기</span>
                    </button>
                    <button id="velocityBtn" class="flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-pink-400 hover:bg-pink-500 text-white text-sm whitespace-nowrap">
                        <i data-lucide="move-right" class="w-4 h-4 icon-velocity"></i>
                        <span id="velocityBtnText">속도 화살표</span>
                    </button>
                </div>
            </div>

            <div class="p-6 grid grid-cols-1 lg:grid-cols-3 gap-8">
                
                <!-- Controls Section -->
                <div class="lg:col-span-1 space-y-8 bg-gray-50 p-6 rounded-xl border border-gray-200">
                    
                    <!-- Frequency Control -->
                    <div class="space-y-3">
                        <div class="flex justify-between items-center">
                            <label class="text-gray-700 font-bold flex items-center gap-2 whitespace-nowrap">
                                <i data-lucide="activity" class="w-4 h-4 text-indigo-600"></i>
                                주파수 (진동수)
                            </label>
                            <span id="freqValue" class="bg-indigo-100 text-indigo-800 px-3 py-1 rounded-full text-sm font-mono font-bold whitespace-nowrap">
                                440 Hz
                            </span>
                        </div>
                        <input id="freqInput" type="range" min="100" max="1000" step="10" value="440" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-indigo-600">
                        <div class="flex justify-between text-xs text-gray-400 px-1">
                            <span>100Hz</span>
                            <span>1000Hz</span>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">
                            주파수가 높을수록 <strong>높은 음(고음)</strong>이 나고, 파동이 촘촘해집니다.
                        </p>
                    </div>

                    <!-- Amplitude Control -->
                    <div class="space-y-3">
                        <div class="flex justify-between items-center">
                            <label class="text-gray-700 font-bold flex items-center gap-2 whitespace-nowrap">
                                <i data-lucide="volume-2" class="w-4 h-4 text-emerald-600"></i>
                                진폭 (소리 크기)
                            </label>
                            <span id="ampValue" class="bg-emerald-100 text-emerald-800 px-3 py-1 rounded-full text-sm font-mono font-bold whitespace-nowrap">
                                50 %
                            </span>
                        </div>
                        <input id="ampInput" type="range" min="0" max="1" step="0.01" value="0.5" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-emerald-600">
                        <p class="text-xs text-gray-500">
                            진폭이 클수록 <strong>큰 소리</strong>가 나고, 파동의 높이가 높아집니다.
                        </p>
                    </div>
                </div>

                <!-- Visualization Section -->
                <div class="lg:col-span-2 space-y-6">
                    
                    <!-- Graph 1: Displacement-Time -->
                    <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-4 relative group">
                        <div class="absolute top-4 left-4 bg-white/90 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-bold text-gray-600 border border-gray-200 shadow-sm z-10">
                            변위-시간 그래프 (횡파적 표현)
                        </div>
                        <canvas id="waveCanvas" class="w-full h-[250px] bg-white rounded-lg cursor-crosshair"></canvas>
                    </div>

                    <!-- Graph 2: Particle Model -->
                    <div class="bg-gray-900 rounded-xl border border-gray-800 shadow-sm p-4 relative">
                        <!-- Label -->
                        <div class="mb-2 inline-block bg-gray-800/90 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-bold text-gray-300 border border-gray-700 shadow-sm">
                            입자 모형 (종파 - 실제 소리의 전달)
                        </div>
                        <canvas id="particleCanvas" class="w-full h-[150px] bg-transparent rounded-lg"></canvas>
                        <div class="mt-2 text-xs text-gray-400 text-center">
                            * 소리는 공기 입자가 빽빽해졌다(밀) 듬성해졌다(소) 하며 전달됩니다.
                        </div>
                    </div>

                    <!-- Graph 3: Relative Velocity -->
                    <div class="bg-indigo-50 rounded-xl border border-indigo-200 shadow-sm p-4 relative">
                        <div class="mb-2 inline-block bg-indigo-100/90 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-bold text-indigo-800 border border-indigo-200 shadow-sm">
                            입자 확대 및 실제 속도 (기준 입자 추적)
                        </div>
                        <canvas id="relativeCanvas" class="w-full h-[150px] bg-transparent rounded-lg"></canvas>
                        <div class="mt-2 text-xs text-indigo-600 text-center">
                            * 가운데 붉은 입자를 따라가며, 세 입자의 <strong>실제 속도</strong>를 화살표로 보여줍니다.
                        </div>
                    </div>

                    <!-- Graph 4: 3D Visualization (New) -->
                    <div class="bg-gray-900 rounded-xl border border-gray-800 shadow-sm p-1 relative overflow-hidden">
                        <div class="absolute top-4 left-4 bg-gray-800/80 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-bold text-gray-300 border border-gray-700 shadow-sm z-10 pointer-events-none">
                            3D 입자 모형 (마우스 드래그로 회전 가능)
                        </div>
                        <div id="threeContainer"></div>
                        <div class="text-xs text-gray-400 text-center p-2">
                            * 45도 각도에서 본 실제 공기 기둥의 파동 모습입니다. (랜덤한 열운동은 생략됨)
                        </div>
                    </div>

                    <!-- Info Box -->
                    <div class="bg-blue-50 border border-blue-100 rounded-xl p-4 flex gap-3">
                        <i data-lucide="info" class="w-6 h-6 text-blue-500 flex-shrink-0 mt-0.5"></i>
                        <div class="text-sm text-blue-800">
                            <p class="font-bold mb-1">실험 가이드:</p>
                            <ul class="list-disc pl-4 space-y-1">
                                <li><strong>주파수(Hz)</strong>를 높이면 그래프의 파동 간격이 좁아지고 음이 높아집니다.</li>
                                <li><strong>진폭</strong>을 높이면 그래프의 위아래 높이가 커지고 소리가 커집니다.</li>
                                <li><strong>점선 보기</strong>를 켜면 <span class="text-red-500 font-bold">밀</span>, <span class="text-blue-500 font-bold">소</span> 위치와 그 <span class="text-gray-500 font-bold">중간 지점</span>을 확인할 수 있습니다.</li>
                                <li>하단의 <strong>컨트롤 패널</strong>을 이용해 입자의 속도가 0이 되는 지점(변위 최대)과 최대가 되는 지점(변위 0)을 멈춰서 확인해보세요.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Control Dock (Sticky Bottom) -->
    <div id="controlDock" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-50 bg-white/95 backdrop-blur-md p-3 rounded-2xl shadow-2xl border border-indigo-100 flex flex-wrap gap-2 justify-center w-[95%] max-w-4xl ring-1 ring-black/5">
        <!-- Physics Observation Buttons -->
        <button id="btnVelZero" class="flex items-center gap-2 px-3 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow bg-blue-500 hover:bg-blue-600 text-white text-xs whitespace-nowrap">
            <span>속도 0<br>(변위 최대)</span>
        </button>
        <button id="btnVelMax" class="flex items-center gap-2 px-3 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow bg-blue-500 hover:bg-blue-600 text-white text-xs whitespace-nowrap">
            <span>속도 최대<br>(변위 0)</span>
        </button>

        <button id="btnStep" class="flex items-center gap-2 px-3 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow bg-blue-500 hover:bg-blue-600 text-white text-xs whitespace-nowrap">
            <span>1/50 주기<br>이동</span>
        </button>

        <!-- Divider -->
        <div class="w-px h-auto bg-gray-300 mx-1"></div>

        <!-- Playback Controls -->
        <button id="animBtn" class="flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow bg-yellow-400 hover:bg-yellow-500 text-yellow-900 text-sm whitespace-nowrap">
            <i data-lucide="pause" class="w-4 h-4 icon-anim"></i>
            <span>정지</span>
        </button>
        <button id="playBtn" class="flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow bg-green-400 hover:bg-green-500 text-indigo-900 text-sm whitespace-nowrap">
            <i data-lucide="play" class="w-4 h-4 icon-state"></i>
            <span>소리 켜기</span>
        </button>
    </div>

    <script>
        // --- State ---
        let isPlaying = false;
        let isAnimating = true;
        let showGuides = false; 
        let showVelocity = false; 
        let frequency = 440;
        let amplitude = 0.5;
        const waveType = 'sine'; // Fixed to sine as requested
        let animationId;
        
        // Audio Context
        let audioContext = null;
        let oscillator = null;
        let gainNode = null;

        // --- DOM Elements ---
        const playBtn = document.getElementById('playBtn');
        const animBtn = document.getElementById('animBtn');
        const guideBtn = document.getElementById('guideBtn');
        const guideBtnText = document.getElementById('guideBtnText');
        const velocityBtn = document.getElementById('velocityBtn');
        const velocityBtnText = document.getElementById('velocityBtnText');
        const freqInput = document.getElementById('freqInput');
        const freqValue = document.getElementById('freqValue');
        const ampInput = document.getElementById('ampInput');
        const ampValue = document.getElementById('ampValue');
        const waveCanvas = document.getElementById('waveCanvas');
        const particleCanvas = document.getElementById('particleCanvas');
        const relativeCanvas = document.getElementById('relativeCanvas');
        const threeContainer = document.getElementById('threeContainer');
        
        // --- Three.js Variables ---
        let scene, camera, renderer;
        let particlesSystem;
        let initialParticlePositions = [];
        let isThreeInitialized = false;

        // --- Resize Handling ---
        function resizeCanvas() {
            const waveContainer = waveCanvas.parentElement;
            const particleContainer = particleCanvas.parentElement;
            const relativeContainer = relativeCanvas.parentElement;
            
            waveCanvas.width = waveContainer.clientWidth;
            waveCanvas.height = 250; 
            
            particleCanvas.width = particleContainer.clientWidth;
            particleCanvas.height = 150; 

            relativeCanvas.width = relativeContainer.clientWidth;
            relativeCanvas.height = 150;

            // Resize Three.js
            if (isThreeInitialized && renderer && camera) {
                const width = threeContainer.clientWidth;
                const height = threeContainer.clientHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        // Call resize initially and after a slight delay to ensure container layout is done
        setTimeout(resizeCanvas, 100);

        // --- Logic ---

        function updateUI() {
            freqValue.innerText = frequency + ' Hz';
            ampValue.innerText = Math.round(amplitude * 100) + ' %';

            if (oscillator && audioContext) {
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            }
            if (gainNode && audioContext) {
                gainNode.gain.setTargetAtTime(amplitude, audioContext.currentTime, 0.02);
            }
        }

        // --- Audio Functions ---

        function startSound() {
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (!audioContext) {
                audioContext = new AudioContextClass();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            oscillator = audioContext.createOscillator();
            gainNode = audioContext.createGain();

            oscillator.type = waveType;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(amplitude, audioContext.currentTime);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();

            isPlaying = true;
            updatePlayButton();
        }

        function stopSound() {
            if (oscillator) {
                const currentTime = audioContext.currentTime;
                gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.05);
                oscillator.stop(currentTime + 0.05);
                
                setTimeout(() => {
                    if (oscillator) oscillator.disconnect();
                    if (gainNode) gainNode.disconnect();
                    oscillator = null;
                }, 100);
            }
            
            isPlaying = false;
            updatePlayButton();
        }

        function togglePlay() {
            if (isPlaying) {
                stopSound();
            } else {
                startSound();
            }
        }

        function updatePlayButton() {
            const iconName = isPlaying ? 'volume-x' : 'play';
            const text = isPlaying ? '소리 끄기' : '소리 켜기';
            const classes = isPlaying 
                ? 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-red-500 hover:bg-red-600 text-white text-sm whitespace-nowrap'
                : 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-green-400 hover:bg-green-500 text-indigo-900 text-sm whitespace-nowrap';
            
            playBtn.className = classes;
            playBtn.innerHTML = `<i data-lucide="${iconName}" class="w-4 h-4"></i><span>${text}</span>`;
            
            if (window.lucide) lucide.createIcons();
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            updateAnimButtonState();
        }

        function updateAnimButtonState() {
            const iconName = isAnimating ? 'pause' : 'play';
            const text = isAnimating ? '정지' : '재생';
            const classes = isAnimating
                ? 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-yellow-400 hover:bg-yellow-500 text-yellow-900 text-sm whitespace-nowrap'
                : 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-blue-400 hover:bg-blue-500 text-white text-sm whitespace-nowrap';

            animBtn.className = classes;
            animBtn.innerHTML = `<i data-lucide="${iconName}" class="w-4 h-4"></i><span>${text}</span>`;
            
            if (window.lucide) lucide.createIcons();
        }

        function toggleGuides() {
            showGuides = !showGuides;
            if (showGuides) {
                guideBtn.className = 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-purple-600 hover:bg-purple-700 text-white text-sm ring-2 ring-purple-300 whitespace-nowrap';
                guideBtnText.innerText = '점선 숨기기';
            } else {
                guideBtn.className = 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-purple-400 hover:bg-purple-500 text-white text-sm whitespace-nowrap';
                guideBtnText.innerText = '점선 보기';
            }
        }

        function toggleVelocity() {
            showVelocity = !showVelocity;
            if (showVelocity) {
                velocityBtn.className = 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-pink-600 hover:bg-pink-700 text-white text-sm ring-2 ring-pink-300 whitespace-nowrap';
                velocityBtnText.innerText = '화살표 숨기기';
            } else {
                velocityBtn.className = 'flex items-center gap-2 px-4 py-2.5 rounded-xl font-bold transition-all transform hover:scale-105 shadow-lg bg-pink-400 hover:bg-pink-500 text-white text-sm whitespace-nowrap';
                velocityBtnText.innerText = '속도 화살표';
            }
        }

        // --- New Physics Observation Buttons Logic ---
        function snapToPhase(targetType) {
            const width = particleCanvas.width;
            const cols = Math.floor(width / 15);
            const targetCol = Math.floor(cols / 2);
            const spacingX = width / cols;
            const targetX = targetCol * spacingX;
            
            const k = 0.01 * (frequency / 200);
            
            if (targetType === 'velocityZero') {
                phase = targetX * k - Math.PI / 2;
            } else if (targetType === 'velocityMax') {
                phase = targetX * k;
            }

            isAnimating = false;
            updateAnimButtonState();
        }

        document.getElementById('btnVelZero').addEventListener('click', () => snapToPhase('velocityZero'));
        document.getElementById('btnVelMax').addEventListener('click', () => snapToPhase('velocityMax'));

        document.getElementById('btnStep').addEventListener('click', () => {
            phase += Math.PI / 25; 
            if (!isAnimating) {
                draw(); // Update both 2D and 3D
            }
        });


        // --- Helper Function for Wave Calculation ---
        function getWaveY(waveType, angle) { 
             return Math.sin(angle); 
        }

        function getWaveVelocityFactor(waveType, angle) {
            return -Math.cos(angle); 
        }

        // --- Three.js Initialization ---
        function initThree() {
            if (isThreeInitialized) return;
            
            const width = threeContainer.clientWidth;
            const height = threeContainer.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // gray-900

            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            camera.position.set(0, 15, 25);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            threeContainer.appendChild(renderer.domElement);

            // Create Particles
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const cylinderLength = 40;
            const cylinderRadius = 5;

            // Generate particles
            for (let i = 0; i < particleCount; i++) {
                // Random position in a cylinder
                const x = (Math.random() - 0.5) * cylinderLength;
                
                // Random position in circle for Y, Z
                const r = Math.sqrt(Math.random()) * cylinderRadius;
                const theta = Math.random() * 2 * Math.PI;
                const y = r * Math.cos(theta);
                const z = r * Math.sin(theta);

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Save initial X for wave calculation
                initialParticlePositions.push({x: x, y: y, z: z});

                // Color based on position (gradient)
                const color = new THREE.Color();
                // Simple color gradient
                color.setHSL(0.5 + x/cylinderLength * 0.2, 0.8, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Material
            // Create a soft circle texture programmatically
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);

            const material = new THREE.PointsMaterial({ 
                size: 0.8, 
                vertexColors: true, 
                map: texture, 
                transparent: true,
                alphaTest: 0.1,
                opacity: 0.9
            });

            particlesSystem = new THREE.Points(geometry, material);
            scene.add(particlesSystem);

            // Simple Orbit Controls (Manual implementation for lightness)
            // Modified to support both Mouse and Touch
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            // --- Mouse Events ---
            threeContainer.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            threeContainer.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };

                    const rotationSpeed = 0.005;
                    particlesSystem.rotation.y += deltaMove.x * rotationSpeed;
                    particlesSystem.rotation.x += deltaMove.y * rotationSpeed;
                }
                previousMousePosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
            });

            // --- Touch Events (Added for Mobile) ---
            threeContainer.addEventListener('touchstart', (e) => {
                isDragging = true;
                const touch = e.touches[0];
                const rect = threeContainer.getBoundingClientRect();
                previousMousePosition = { 
                    x: touch.clientX - rect.left, 
                    y: touch.clientY - rect.top 
                };
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });

            threeContainer.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const rect = threeContainer.getBoundingClientRect();
                    const currentX = touch.clientX - rect.left;
                    const currentY = touch.clientY - rect.top;

                    const deltaMove = {
                        x: currentX - previousMousePosition.x,
                        y: currentY - previousMousePosition.y
                    };

                    const rotationSpeed = 0.005;
                    particlesSystem.rotation.y += deltaMove.x * rotationSpeed;
                    particlesSystem.rotation.x += deltaMove.y * rotationSpeed;

                    previousMousePosition = {
                        x: currentX,
                        y: currentY
                    };

                    // Prevent scrolling while rotating the 3D model
                    if (e.cancelable) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            isThreeInitialized = true;
        }

        // --- 3D Update Function ---
        function updateThree() {
            if (!isThreeInitialized || !particlesSystem) return;

            const positions = particlesSystem.geometry.attributes.position.array;
            
            // Map Frequency to Wave Number k
            // Visual scale factor to match 2D graph
            const visualScaleFactor = 0.05; 
            const k = 0.01 * (frequency / 200) * 10; // Adjust for 3D scale

            // The 'phase' variable is updated in the main draw() loop
            // We use the same phase to sync. 
            // 2D Phase speed was: phase += frequency * 0.00008
            // We use the exact same global 'phase' variable.

            for (let i = 0; i < initialParticlePositions.length; i++) {
                const initX = initialParticlePositions[i].x;
                
                // Need to map 3D X coordinates to the phase logic
                // x range is roughly -20 to 20
                // Shift to positive for calculation if needed, or just use as is
                
                // Calculate Displacement
                // k * x - phase
                // x in 3D is different scale than canvas pixels. 
                // Let's map it: 3D x * factor matches canvas x
                
                const angle = (initX + 20) * 2 * k - phase; // +20 to shift start
                const waveVal = Math.sin(angle);
                
                // Displacement amount
                const maxDisp = 3.0; // Max displacement in 3D units
                const disp = waveVal * (amplitude * maxDisp);

                // Update X position: Initial + Displacement
                positions[i * 3] = initX + disp;
            }
            
            particlesSystem.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }


        // --- Animation Loop ---
        let phase = 0;

        function draw() {
            const k = 0.01 * (frequency / 200);

            if (isAnimating) {
                // Main loop speed
                phase += frequency * 0.00008;
            }

            // 1. Update 3D
            if (document.getElementById('threeContainer').offsetParent !== null) {
                // Initialize if visible and not yet done
                if (!isThreeInitialized && window.THREE) {
                    initThree();
                }
                updateThree();
            }

            // 2. Analytical Guide Line Calculation (2D)
            const guideLines = [];
            if (showGuides) {
                const width = waveCanvas ? waveCanvas.width : 600;
                
                const stepAngle = Math.PI / 2;
                const minArg = -phase;
                const maxArg = width * k - phase;
                
                const mMin = Math.ceil(minArg / stepAngle);
                const mMax = Math.floor(maxArg / stepAngle);

                for (let m = mMin; m <= mMax; m++) {
                    const x = (m * stepAngle + phase) / k;
                    const mod = (m % 4 + 4) % 4; 
                    
                    let type = '';
                    if (mod === 0) type = 'rarefaction';
                    else if (mod === 2) type = 'compression';
                    else type = 'middle';

                    guideLines.push({ x: x, type: type });
                }
            }

            // 3. Draw Graph 1: Transverse Wave
            if (waveCanvas) {
                const ctx = waveCanvas.getContext('2d');
                const width = waveCanvas.width;
                const height = waveCanvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                ctx.beginPath();
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#4F46E5'; 
                
                const visualAmp = (amplitude * height) / 2.2; 
                const step = 2;
                
                let prevY = getWaveY(waveType, -phase) * visualAmp;
                
                ctx.moveTo(0, height / 2 - prevY);
                
                for (let x = 0; x <= width; x += step) {
                    const angle = x * k - phase;
                    const y = getWaveY(waveType, angle) * visualAmp;
                    
                    if (x > 0) ctx.lineTo(x, height / 2 - y);
                    prevY = y;
                }
                ctx.stroke();

                if (showGuides) {
                    guideLines.forEach(line => {
                        ctx.save();
                        ctx.beginPath();
                        
                        if (line.type === 'middle') {
                            ctx.setLineDash([2, 4]);
                            ctx.strokeStyle = 'rgba(156, 163, 175, 0.6)'; 
                            ctx.lineWidth = 1;
                        } else {
                            ctx.setLineDash([4, 4]);
                            ctx.lineWidth = 1.5;
                            ctx.strokeStyle = line.type === 'compression' ? 'rgba(239, 68, 68, 0.6)' : 'rgba(59, 130, 246, 0.6)'; 
                        }
                        
                        ctx.moveTo(line.x, 0);
                        ctx.lineTo(line.x, height);
                        ctx.stroke();
                        
                        if (line.type !== 'middle') {
                            ctx.fillStyle = '#ffffff';
                            const textWidth = 14; 
                            const textHeight = 14;
                            ctx.fillRect(line.x - textWidth/2, 15 - textHeight + 3, textWidth, textHeight);

                            ctx.fillStyle = line.type === 'compression' ? 'rgba(239, 68, 68, 1)' : 'rgba(59, 130, 246, 1)'; 
                            ctx.font = '10px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(line.type === 'compression' ? '밀' : '소', line.x, 15);
                        }
                        ctx.restore();
                    });
                }

                // 4. Draw Graph 2: Particle System (Longitudinal)
                if (particleCanvas) {
                    const pCtx = particleCanvas.getContext('2d');
                    const pWidth = particleCanvas.width;
                    const pHeight = particleCanvas.height;
                    
                    pCtx.clearRect(0, 0, pWidth, pHeight);

                    if (showGuides) {
                        guideLines.forEach(line => {
                            pCtx.save();
                            pCtx.beginPath();
                            
                            if (line.type === 'middle') {
                                pCtx.setLineDash([2, 4]);
                                pCtx.strokeStyle = 'rgba(156, 163, 175, 0.4)'; 
                                pCtx.lineWidth = 1;
                            } else {
                                pCtx.setLineDash([4, 4]);
                                pCtx.lineWidth = 1.5;
                                pCtx.strokeStyle = line.type === 'compression' ? 'rgba(239, 68, 68, 0.4)' : 'rgba(59, 130, 246, 0.4)';
                            }
                            
                            pCtx.moveTo(line.x, 0);
                            pCtx.lineTo(line.x, pHeight);
                            pCtx.stroke();
                            pCtx.restore();
                        });
                    }

                    const rows = 5;
                    const cols = Math.floor(pWidth / 15); 
                    const spacingX = pWidth / cols;
                    const spacingY = pHeight / (rows + 1);

                    const targetRow = 0; 
                    const targetCol = Math.floor(cols / 2);

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c <= cols; c++) {
                            const baseX = c * spacingX; 
                            const baseY = (r + 1) * spacingY;

                            const maxDisplacement = spacingX * 1.2; 
                            
                            const angle = baseX * k - phase;
                            const waveVal = getWaveY(waveType, angle);
                            
                            const displacement = waveVal * (amplitude * maxDisplacement);
                            
                            pCtx.fillStyle = (c % 2 === 0) ? '#10B981' : '#F59E0B'; 

                            const px = baseX + displacement;
                            const py = baseY;

                            pCtx.beginPath();
                            pCtx.arc(px, py, 3, 0, Math.PI * 2);
                            pCtx.fill();

                            if (showVelocity && r === targetRow && c === targetCol) {
                                const velFactor = getWaveVelocityFactor(waveType, angle);
                                const velScale = 1.5 * Math.sqrt(frequency);
                                const velVector = velFactor * amplitude * velScale;

                                pCtx.save();
                                pCtx.strokeStyle = '#E11D48';
                                pCtx.fillStyle = '#E11D48';
                                pCtx.lineWidth = 2;

                                pCtx.beginPath();
                                pCtx.moveTo(px, py - 12);
                                pCtx.lineTo(px + velVector, py - 12);
                                pCtx.stroke();

                                if (Math.abs(velVector) > 2) {
                                    const headSize = 4;
                                    const dir = velVector > 0 ? 1 : -1;
                                    const endX = px + velVector;
                                    const endY = py - 12;
                                    
                                    pCtx.beginPath();
                                    pCtx.moveTo(endX, endY);
                                    pCtx.lineTo(endX - headSize * dir, endY - headSize);
                                    pCtx.lineTo(endX - headSize * dir, endY + headSize);
                                    pCtx.fill();
                                }
                                pCtx.restore();
                                
                                pCtx.beginPath();
                                pCtx.strokeStyle = '#E11D48';
                                pCtx.lineWidth = 2;
                                pCtx.arc(px, py, 5, 0, Math.PI * 2);
                                pCtx.stroke();
                            }
                        }
                    }
                }

                // 5. Draw Graph 3: Actual Velocity (Zoomed)
                if (relativeCanvas) {
                    const rCtx = relativeCanvas.getContext('2d');
                    const rWidth = relativeCanvas.width;
                    const rHeight = relativeCanvas.height;
                    
                    rCtx.clearRect(0, 0, rWidth, rHeight);

                    rCtx.strokeStyle = '#e5e7eb';
                    rCtx.lineWidth = 2;
                    rCtx.beginPath();
                    rCtx.moveTo(0, rHeight/2);
                    rCtx.lineTo(rWidth, rHeight/2);
                    rCtx.stroke();

                    const cols = Math.floor(particleCanvas.width / 15);
                    const targetCol = Math.floor(cols / 2);
                    const spacingX = particleCanvas.width / cols;
                    
                    const zoom = 4.0;
                    const centerX = rWidth / 2;
                    
                    const idxs = [-1, 0, 1]; 
                    
                    const targetBaseX = targetCol * spacingX;
                    const targetAngle = targetBaseX * k - phase;
                    const targetVelFactor = getWaveVelocityFactor(waveType, targetAngle);
                    const targetVel = targetVelFactor * amplitude; 

                    idxs.forEach(i => {
                        const colIdx = targetCol + i;
                        const baseX = colIdx * spacingX;
                        const angle = baseX * k - phase;
                        
                        const waveVal = getWaveY(waveType, angle);
                        const maxDisp = spacingX * 1.2;
                        const disp = waveVal * (amplitude * maxDisp);
                        
                        const velFactor = getWaveVelocityFactor(waveType, angle);
                        const vel = velFactor * amplitude;
                        
                        const targetActualX = targetBaseX + getWaveY(waveType, targetAngle) * (amplitude * maxDisp);
                        const currentActualX = baseX + disp;
                        
                        const drawX = centerX + (currentActualX - targetActualX) * zoom;
                        const drawY = rHeight / 2;
                        
                        rCtx.beginPath();
                        rCtx.arc(drawX, drawY, 10, 0, Math.PI * 2); 
                        
                        if (i === 0) {
                            rCtx.fillStyle = '#E11D48'; 
                        } else {
                            rCtx.fillStyle = '#F59E0B'; 
                        }
                        rCtx.fill();
                        rCtx.strokeStyle = '#000';
                        rCtx.lineWidth = 1;
                        rCtx.stroke();
                        
                        const velScale = 150 * Math.sqrt(frequency/440); 
                        const arrowLen = vel * velScale; 
                        
                        if (Math.abs(arrowLen) > 1) {
                            rCtx.save();
                            
                            let arrowColor = '#4F46E5';
                            if (i === -1) arrowColor = '#2563EB'; 
                            else if (i === 0) arrowColor = '#E11D48'; 
                            else if (i === 1) arrowColor = '#059669'; 

                            rCtx.strokeStyle = arrowColor;
                            rCtx.fillStyle = arrowColor;
                            rCtx.lineWidth = 3;
                            
                            let yOffset = -25;
                            if (i === -1) yOffset = -55;
                            else if (i === 0) yOffset = -40;
                            else if (i === 1) yOffset = -25;

                            const arrowY = drawY + yOffset; 
                            
                            rCtx.beginPath();
                            rCtx.moveTo(drawX, arrowY);
                            rCtx.lineTo(drawX + arrowLen, arrowY);
                            rCtx.stroke();
                            
                            const headSize = 6;
                            const dir = arrowLen > 0 ? 1 : -1;
                            const endX = drawX + arrowLen;
                            
                            rCtx.beginPath();
                            rCtx.moveTo(endX, arrowY);
                            rCtx.lineTo(endX - headSize * dir, arrowY - headSize);
                            rCtx.lineTo(endX - headSize * dir, arrowY + headSize);
                            rCtx.fill();
                            
                            rCtx.restore();
                        }
                        
                        let labelColor = '#4b5563';
                        if (i === -1) labelColor = '#2563EB';
                        else if (i === 0) labelColor = '#E11D48';
                        else if (i === 1) labelColor = '#059669';

                        rCtx.fillStyle = labelColor;
                        rCtx.font = 'bold 12px sans-serif';
                        rCtx.textAlign = 'center';
                        let label = "";
                        if (i === -1) label = "왼쪽";
                        if (i === 0) label = "나(추적)";
                        if (i === 1) label = "오른쪽";
                        rCtx.fillText(label, drawX, drawY + 30);
                    });
                }
            }

            animationId = requestAnimationFrame(draw);
        }

        // --- Event Listeners ---

        playBtn.addEventListener('click', togglePlay);
        animBtn.addEventListener('click', toggleAnimation);
        guideBtn.addEventListener('click', toggleGuides);
        velocityBtn.addEventListener('click', toggleVelocity);

        freqInput.addEventListener('input', (e) => {
            frequency = Number(e.target.value);
            updateUI();
        });

        ampInput.addEventListener('input', (e) => {
            amplitude = Number(e.target.value);
            updateUI();
        });

        // --- Initialization ---
        window.onload = () => {
            if (window.lucide) lucide.createIcons();
            draw();
            resizeCanvas(); 
        };

    </script>
</body>
</html>
